
group by 
```
group by 即分组，主要作用是把一个集合中根据group by的关键字进行分组，内含两个计算
1）去掉重复值,根据group by后面的列，在内存中创建一个对应为PK的临时表，没有的话就插入，有的话对应的聚合函数部分进行比较，使最终结果中没有重复值
例：
root@192.168.0.254 3308 [employees]>select dept_no from t_group;
+---------+
| dept_no |
+---------+
| d002    |
| d004    |
| d005    |
| d005    |
| d005    |
| d005    |
| d006    |
| d007    |
| d008    |
| d008    |
+---------+
10 rows in set (0.00 sec)
root@192.168.0.254 3307 [employees]>select dept_no from t_group group by dept_no;   //5.7
+---------+
| dept_no |
+---------+
| d002    |
| d004    |
| d005    |
| d006    |
| d007    |
| d008    |
+---------+
6 rows in set (0.00 sec)

5.7通过group by 后面添加orderby null 来去掉using filesort，但是实际优化效果不明显，，因为排序是对聚合之后的结果集，聚合之后结果集往往较小,应该去掉是using temporary，如果where 条件有良好的索引，那么就可以去除using temporary
root@192.168.0.254 3307 [employees]>desc select dept_no from t_group group by dept_no;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
|  1 | SIMPLE      | t_group | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | Using temporary; Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+

root@192.168.0.254 3307 [employees]>show status like '%sort%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 0     |
| Sort_scan         | 0     |
+-------------------+-------+
4 rows in set (0.17 sec)

root@192.168.0.254 3307 [employees]>select dept_no from t_group group by dept_no;
+---------+
| dept_no |
+---------+
| d002    |
| d004    |
| d005    |
| d006    |
| d007    |
| d008    |
+---------+
6 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>show status like '%sort%';  //查看排序的行
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 6     |
| Sort_scan         | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>show status like '%tmp%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |
| Created_tmp_files       | 0     |
| Created_tmp_tables      | 1     |
+-------------------------+-------+
3 rows in set (0.01 sec)


root@192.168.0.254 3308 [employees]>select dept_no from t_group group by dept_no;   //8.0
+---------+
| dept_no |
+---------+
| d004    |
| d006    |
| d005    |
| d002    |
| d008    |
| d007    |
+---------+
6 rows in set (0.00 sec

root@192.168.0.254 3308 [employees]>desc select dept_no from t_group group by dept_no;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | SIMPLE      | t_group | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | Using temporary |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+

group by 字符串类型，排序是按ascii码顺序来排序的
root@192.168.0.254 3307 [employees]>select a from (
    -> select 'a9' a union all
    -> select 'a6' a union all
    -> select 'a3' a union all
    -> select 'a7' a union all
    -> select 'aa' a union all
    -> select 'ab' a union all
    -> select 'a0' a union all
    -> select 'a10'
    -> ) c
    -> group by a;
+-----+
| a   |
+-----+
| a0  |
| a10 |
| a3  |
| a6  |
| a7  |
| a9  |
| aa  |
| ab  |
+-----+
8 rows in set (0.02 sec)

数字类型按大小排序，
root@192.168.0.254 3307 [employees]>select a from (
    -> select 100 a union all
    -> select 88 a union all
    -> select 3 a union all
    -> select 345 a union all
    -> select 4 a union all
    -> select 7 a union all
    -> select 0 a union all
    -> select 333
    -> ) c
    -> group by a;
+-----+
| a   |
+-----+
|   0 |
|   3 |
|   4 |
|   7 |
|  88 |
| 100 |
| 333 |
| 345 |
+-----+
8 rows in set (0.00 sec)

包含null的情况
root@192.168.0.254 3307 [employees]>select a from (
    -> select 100 a union all
    -> select null a union all
    -> select 3 a union all
    -> select 345 a union all
    -> select 4 a union all
    -> select 333
    -> ) c
    -> group by a;
+------+
| a    |
+------+
| NULL |
|    3 |
|    4 |
|  100 |
|  333 |
|  345 |
+------+
6 rows in set (0.00 sec)

包含 ''和null时
root@192.168.0.254 3307 [employees]>
root@192.168.0.254 3307 [employees]>select a from (
    -> select 100 a union all
    -> select '' a union all
    -> select 3 a union all
    -> select 345 a union all
    -> select null a union all
    -> select 333
    -> ) c
    -> group by a;
+------+
| a    |
+------+
| NULL |
|      |
| 100  |
| 3    |
| 333  |
| 345  |
+------+
6 rows in set (0.02 sec)

使用hex排序
root@192.168.0.254 3307 [employees]>select hex(a) from (
    -> select 100 a union all
    -> select '' a union all
    -> select 3 a union all
    -> select 345 a union all
    -> select null a union all
    -> select 333
    -> ) c
    -> group by a;
+--------+
| hex(a) |
+--------+
| NULL   |
|        |
| 313030 |
| 33     |
| 333333 |
| 333435 |
+--------+
6 rows in set (0.00 sec)


2）进行排序(5.5-5.7), 8.0开始没排序，对group by后面的关键字进行排序
3)相关配置参数,tmp_table_size,max_heap_table_size

GROUP BY 进行数据统计时，如果有索引，就不需要进行成生临时表，因为索引本身是有顺序的，只需要一个计数器就可以完成，
使用索引减少using tempfile两种方式 
1） Loose Index Scan   索引跳跃式扫描
    联合索引的前导列选择率要低，必须都在索引中
    前导列是关键
root@192.168.0.254 3307 [employees]>desc  select dept_no,to_date from t_group5 group by dept_no,to_date;
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_group5 | NULL       | range | ix_empno_to_date | ix_empno_to_date | 15      | NULL |    7 |   100.00 | Using index for group-by |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+

distinct 也一样可以触发
root@192.168.0.254 3307 [employees]>desc select distinct dept_no,to_date from t_group5;
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t_group5 | NULL       | range | ix_empno_to_date | ix_empno_to_date | 15      | NULL |    7 |   100.00 | Using index for group-by |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)

group by顺序不按照索引顺序的时候不出现, select时及group by时，最好跟索引顺序一样，
root@192.168.0.254 3308 [employees]>desc select to_date,dept_no from t_group5 group by to_date,dept_no;
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+---------+----------+------------------------------+
| id | select_type | table    | partitions | type  | possible_keys    | key              | key_len | ref  | rows    | filtered | Extra                        |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+---------+----------+------------------------------+
|  1 | SIMPLE      | t_group5 | NULL       | index | ix_empno_to_date | ix_empno_to_date | 15      | NULL | 2460672 |   100.00 | Using index; Using temporary |
+----+-------------+----------+------------+-------+------------------+------------------+---------+------+---------+----------+------------------------------+
1 row in set, 1 warning (0.01 sec)

2） Tight index Scan   range scan或者 index scan
Group by使用索引减少using tempfile的两种方式range scan或index scan 

创建索引的时候必须按照where条件是否还有等号 + group by 后面的顺序来创建,, group by性能最严重的就是使用临时表
root@192.168.0.254 3307 [employees]>alter table t_group5 add index idx_4 (to_date,dept_no,emp_no);   //效果好
Query OK, 0 rows affected (24.50 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@192.168.0.254 3307 [employees]>desc select dept_no,to_date,emp_no from t_group5 where to_date='9999-01-01' group by dept_no,emp_no;
+----+-------------+----------+------------+------+---------------+-------+---------+-------+---------+----------+--------------------------+
| id | select_type | table    | partitions | type | possible_keys | key   | key_len | ref   | rows    | filtered | Extra                    |
+----+-------------+----------+------------+------+---------------+-------+---------+-------+---------+----------+--------------------------+
|  1 | SIMPLE      | t_group5 | NULL       | ref  | idx_4         | idx_4 | 3       | const | 1307520 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+------+---------------+-------+---------+-------+---------+----------+--------------------------+

root@192.168.0.254 3307 [employees]>alter table t_group5 add index idx_4 (dept_no,emp_no);      //效果不理想
Query OK, 0 rows affected (19.82 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@192.168.0.254 3307 [employees]>desc select dept_no,to_date,emp_no from t_group5 where to_date='9999-01-01' group by dept_no,emp_no;
+----+-------------+----------+------------+-------+---------------+-------+---------+------+---------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key   | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+-------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | t_group5 | NULL       | index | idx_4         | idx_4 | 16      | NULL | 2615040 |    10.00 | Using where |
+----+-------------+----------+------------+-------+---------------+-------+---------+------+---------+----------+-------------+


group by 不完全随计执行计划不同导致结果不同
root@192.168.0.254 3308 [employees]>desc t_order2;
+-----------+---------+------+-----+---------+-------+
| Field     | Type    | Null | Key | Default | Extra |
+-----------+---------+------+-----+---------+-------+
| emp_no    | int     | YES  |     | NULL    |       |
| dept_no   | char(4) | YES  | MUL | NULL    |       |
| from_date | date    | YES  |     | NULL    |       |
| to_date   | date    | YES  |     | NULL    |       |
+-----------+---------+------+-----+---------+-------+
4 rows in set (0.05 sec)

root@192.168.0.254 3308 [employees]>select * from t_order2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  30971 | d005    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)


root@192.168.0.254 3308 [employees]>show index from t_order2;
+----------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table    | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+----------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| t_order2 |          1 | ix_t_order2  |            1 | dept_no     | A         |           6 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| t_order2 |          1 | ix_t_order_3 |            1 | dept_no     | A         |           6 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| t_order2 |          1 | ix_t_order_3 |            2 | emp_no      | A         |          10 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+----------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.02 sec)

root@192.168.0.254 3308 [employees]>desc select t.*,count(1) from t_order2 t group by t.dept_no;
+----+-------------+-------+------------+-------+--------------------------+-------------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys            | key         | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+-------+--------------------------+-------------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t     | NULL       | index | ix_t_order2,ix_t_order_3 | ix_t_order2 | 13      | NULL |   10 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+--------------------------+-------------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

root@192.168.0.254 3308 [employees]>select t.*,count(1) from t_order2 t group by t.dept_no;
+--------+---------+------------+------------+----------+
| emp_no | dept_no | from_date  | to_date    | count(1) |
+--------+---------+------------+------------+----------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |        1 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |        1 |
|  30971 | d005    | 1986-12-01 | 9999-01-01 |        4 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |        1 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |        1 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |        2 |
+--------+---------+------------+------------+----------+
6 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>desc select t.*,count(1) from t_order2 t force index (ix_t_order_3) group by t.dept_no;
+----+-------------+-------+------------+-------+--------------------------+--------------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys            | key          | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+-------+--------------------------+--------------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t     | NULL       | index | ix_t_order2,ix_t_order_3 | ix_t_order_3 | 18      | NULL |   10 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+--------------------------+--------------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

root@192.168.0.254 3308 [employees]>select t.*,count(1) from t_order2 t force index (ix_t_order_3) group by t.dept_no;     //使用不同索引后d005的emp_no值不同了
+--------+---------+------------+------------+----------+
| emp_no | dept_no | from_date  | to_date    | count(1) |
+--------+---------+------------+------------+----------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |        1 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |        1 |
|  24007 | d005    | 1986-12-01 | 2017-03-29 |        4 | 
|  22744 | d006    | 1986-12-01 | 9999-01-01 |        1 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |        1 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |        2 |
+--------+---------+------------+------------+----------+
6 rows in set (0.00 sec)

distinct跟group by 一样在内存中创建唯一主键表，没有就插入，有的话就违反UK约束
跟distinct一个效果，但distinct不排序
root@192.168.0.254 3308 [employees]> select distinct dept_no from t_group;
+---------+
| dept_no |
+---------+
| d004    |
| d006    |
| d005    |
| d002    |
| d008    |
| d007    |
+---------+
6 rows in set (0.00 se
```

order by 
```
order by  基本用法, order by 后面可以写列名

root@192.168.0.254 3307 [employees]>select * from t_group order by emp_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.10 sec)

root@192.168.0.254 3307 [employees]>select * from t_group order by emp_no desc ;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+

也可以写 1，2，3 ，4，但不建议这样
root@192.168.0.254 3307 [employees]>select * from t_group order by 2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>select * from t_group order by 2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+

有null有情况，null放在第一位
root@192.168.0.254 3307 [employees]>select * from t_order  order by emp_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.04 sec)

order by 字符型，根据一个字符一个字符来比较
root@192.168.0.254 3307 [employees]>select * from t_order order by dept_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

order by 高级用法，如把d008放在第一位，在d008中emp_no为null的放在下面其它的按照d002-d007排序
root@192.168.0.254 3307 [employees]>select * from t_order order by case when dept_no='d008' then '1' else dept_no end asc ,emp_no desc;   //参与排序时d008相当于字符串的'1'，emp_no desc意思是默认空在第一位所以做了降序
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.02 sec)

order by 排序时注意使用别名，有可能用不到索引
root@192.168.0.254 3307 [employees]>show index from t_group;
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table   | Non_unique | Key_name   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| t_group |          1 | idx_emp_no |            1 | emp_no      | A         |          10 |     NULL | NULL   |      | BTREE      |         |               |
| t_group |          1 | idx_dep_no |            1 | dept_no     | A         |           6 |     NULL | NULL   |      | BTREE      |         |               |
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>desc select  dept_no from t_group order by dept_no desc ;
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_group | NULL       | index | NULL          | idx_dep_no | 12      | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)


root@192.168.0.254 3307 [employees]>desc select dept_no +0 as dept_no from t_group order by dept_no desc ;    //使用了别名后不能使用索引
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                       |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------------+
|  1 | SIMPLE      | t_group | NULL       | index | NULL          | idx_dep_no | 12      | NULL |   10 |   100.00 | Using index; Using filesort |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------------+
1 row in set, 1 warning (0.01 sec)

group + order by特殊用途,求分组中最大或者最小的数，，以下四种方法，都可以达到同样的效果
传统方法
1、求出每个dept_no组的最大emp_no
2、然后拿这个值与原来的表进行join
root@192.168.0.254 3307 [employees]>select t.* from (select dept_no,max(emp_no) emp_no from t_order group by dept_no) a join t_order t on a.emp_no=t.emp_no and a.dept_no=t.dept_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+

group by + order by 完美理解后的方法
root@192.168.0.254 3307 [employees]>select * from t_order order by dept_no asc, emp_no desc;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
+--------+---------+------------+------------+
10 rows in set (0.01 sec)

root@192.168.0.254 3307 [employees]>select a.* from (select * from t_order order by dept_no asc, emp_no desc limit 100) a group by a.dept_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
6 rows in set (0.00 sec)

另一种方法
root@192.168.0.254 3307 [employees]>select * from t_group2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>select * from t_group2 t1 where not exists (select 1 from t_group2 t2 where t1.dept_no=t2.dept_no and t1.emp_no < t2.emp_no) order by 2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
6 rows in set (0.02 sec)

root@192.168.0.254 3307 [employees]>desc select * from t_group2 t1 where not exists (select 1 from t_group2 t2 where t1.dept_no=t2.dept_no and t1.emp_no < t2.emp_no) order by 2;
+----+--------------------+-------+------------+------+---------------+-------------+---------+----------------------+------+----------+-----------------------------+
| id | select_type        | table | partitions | type | possible_keys | key         | key_len | ref                  | rows | filtered | Extra                       |
+----+--------------------+-------+------------+------+---------------+-------------+---------+----------------------+------+----------+-----------------------------+
|  1 | PRIMARY            | t1    | NULL       | ALL  | NULL          | NULL        | NULL    | NULL                 |   10 |   100.00 | Using where; Using filesort |
|  2 | DEPENDENT SUBQUERY | t2    | NULL       | ref  | ix_dept_no2   | ix_dept_no2 | 12      | employees.t1.dept_no |    1 |    33.33 | Using where                 |
+----+--------------------+-------+------------+------+---------------+-------------+---------+----------------------+------+----------+-----------------------------+
2 rows in set, 3 warnings (0.00 sec)

MySQL8.0窗口函数
root@192.168.0.254 3308 [employees]>select t.*,row_number() over(partition by t.dept_no order by emp_no) rn from t_group2 t;
+--------+---------+------------+------------+----+
| emp_no | dept_no | from_date  | to_date    | rn |
+--------+---------+------------+------------+----+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |  1 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |  1 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |  1 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |  2 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |  3 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |  4 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |  1 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |  1 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |  1 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |  2 |
+--------+---------+------------+------------+----+
10 rows in set (0.01 sec)

root@192.168.0.254 3308 [employees]>select * from (
    -> select t.*,row_number() over(partition by t.dept_no order by emp_no) rn from t_group2 t
    -> ) c where rn=1;
+--------+---------+------------+------------+----+
| emp_no | dept_no | from_date  | to_date    | rn |
+--------+---------+------------+------------+----+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |  1 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |  1 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |  1 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |  1 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |  1 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |  1 |
+--------+---------+------------+------------+----+
6 rows in set (0.15 sec)

```
order by 之内部算法
```
两种排序方法
single pass: MySQL默认方法
原理，一次性把SQL中涉及到的字段全部读取出来，然后依据排序字段排序，最后直接返回结果，
优点：一次顺序IO，无须任何随机IO，大大降低IO开销
缺点：内存容不下那么多数据时，可能会先放在磁盘上，对大数据切分，单个小块排序，排完序再到放回磁盘，待所有单块排完，最后进行结果集merge(合并)，再返回排序结果
root@192.168.0.254 3308 [employees]>flush status;
Query OK, 0 rows affected (0.09 sec)

root@192.168.0.254 3308 [employees]>show status like '%sort%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 0     |
| Sort_scan         | 0     |
+-------------------+-------+
4 rows in set (0.18 sec)

root@192.168.0.254 3308 [employees]>select emp_no,first_name,last_name from employees order by first_name limit 10; //排序时会把所有字段存入内存，格式为 first_name,emp_no,first_name,last_name
+--------+------------+-------------+
| emp_no | first_name | last_name   |
+--------+------------+-------------+
|  11935 | Aamer      | Jayawardene |
|  13011 | Aamer      | Glowinski   |
|  22279 | Aamer      | Kornyak     |
|  20678 | Aamer      | Parveen     |
|  23269 | Aamer      | Szmurlo     |
|  12160 | Aamer      | Garrabrants |
|  24404 | Aamer      | Tsukuda     |
|  11800 | Aamer      | Fraisse     |
|  28043 | Aamer      | Kroll       |
|  15332 | Aamer      | Slutz       |
+--------+------------+-------------+
10 rows in set (1.40 sec)

root@192.168.0.254 3308 [employees]>show status like '%sort%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |   //排序有没有合并，数据量一般是1排序，数据量大，可能会多次排序
| Sort_range        | 0     |
| Sort_rows         | 10    |   //排序的行
| Sort_scan         | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>flush status;
root@192.168.0.254 3308 [employees]>select emp_no,first_name,last_name from employees order by first_name limit 1000000;     //数据量大时，会多次合并
root@192.168.0.254 3308 [employees]>show status like '%sort%';
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 12     |          //合并了12次
| Sort_range        | 0      |
| Sort_rows         | 300024 |
| Sort_scan         | 1      |
+-------------------+--------+
4 rows in set (0.01 sec)


two pass:
原理：先读取行指针和排序字段，进行排序，而后依据排序结果再去读取所需要的数据
优点，排序的数据量较小，完全可以在内存中完成
缺点：第二次读取时，会发生大量随机IO，太昂贵 
root@192.168.0.254 3308 [employees]>show variables like '%max_length%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| max_length_for_sort_data | 4096  |
+--------------------------+-------+
要排序的列的值大于上面的值或者select列当中含 blob或text的值
root@192.168.0.254 3308 [employees]>desc t11;
+-------+-----------+------+-----+---------+----------------+
| Field | Type      | Null | Key | Default | Extra          |
+-------+-----------+------+-----+---------+----------------+
| a1    | bigint    | NO   | PRI | NULL    | auto_increment |
| c10   | char(10)  | YES  |     | NULL    |                |
| c100  | char(100) | YES  |     | NULL    |                |
| c200  | char(200) | YES  |     | NULL    |                |
| c30   | char(255) | YES  |     | NULL    |                |
| c300  | text      | YES  |     | NULL    |                |
+-------+-----------+------+-----+---------+----------------+
6 rows in set (0.03 sec)

root@192.168.0.254 3308 [employees]>flush status;
Query OK, 0 rows affected (0.01 sec)

root@192.168.0.254 3308 [employees]>show status  like '%sort%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 0     |
| Sort_scan         | 0     |
+-------------------+-------+
4 rows in set (0.01 sec)

root@192.168.0.254 3308 [employees]>select SQL_NO_CACHE count(1) from (select * from t11 ignore index (primary) order by c10 desc limit 100000) a;
root@192.168.0.254 3308 [employees]>show status  like '%sort%';
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 4      |
| Sort_range        | 0      |
| Sort_rows         | 100000 |
| Sort_scan         | 1      |
+-------------------+--------+
4 rows in set (0.07 sec)

sort_merge_pass超过sort buffer当中就会数据写入temp file当中，然后把temp file合并的次数数据大小跟sort_buffer_size有直接关系
此SQL优化思路，使用延迟join的形式，减少排序的面积
```
order by limit有重复列的情况
```
如表
root@192.168.0.254 3306 [employees]>show create table s1 \G
*************************** 1. row ***************************
       Table: s1
Create Table: CREATE TABLE `s1` (
  `c1` int(11) NOT NULL,
  `c2` varchar(10) DEFAULT NULL,
  `c3` varchar(10) DEFAULT NULL,
  `c4` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`),
  KEY `idx_c3` (`c3`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8


root@192.168.0.254 3306 [employees]>select * from s1;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 | 1    | 1    | 1    |
|  2 | 2    | 2    | 2    |
|  3 | 3    | 3    | 3    |
|  4 | 4    | 4    | 4    |
|  5 | 4    | 4    | 5    |
|  6 | 4    | 4    | 6    |
|  7 | 4    | 4    | 7    |
|  8 | 4    | 4    | 8    |
+----+------+------+------+
8 rows in set (0.01 sec)

root@192.168.0.254 3306 [employees]>select * from s1 order by c3 limit 0,4;  //c1=8两次都出现了
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 | 1    | 1    | 1    |
|  2 | 2    | 2    | 2    |
|  3 | 3    | 3    | 3    |
|  8 | 4    | 4    | 8    |
+----+------+------+------+
4 rows in set (0.01 sec)

root@192.168.0.254 3306 [employees]>select * from s1 order by c3 limit 4,4;            //c1=8两次都出现了
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  5 | 4    | 4    | 5    |
|  6 | 4    | 4    | 6    |
|  7 | 4    | 4    | 7    |
|  8 | 4    | 4    | 8    |
+----+------+------+------+
4 rows in set (0.01 sec)

解决办法，在order by 后面加上两个字段，如后面加在pk
root@192.168.0.254 3306 [employees]>select * from s1 order by c3,c1 limit 0,4;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 | 1    | 1    | 1    |
|  2 | 2    | 2    | 2    |
|  3 | 3    | 3    | 3    |
|  4 | 4    | 4    | 4    |
+----+------+------+------+
4 rows in set (0.01 sec)

root@192.168.0.254 3306 [employees]>select * from s1 order by c3,c1 limit 4,4;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  5 | 4    | 4    | 5    |
|  6 | 4    | 4    | 6    |
|  7 | 4    | 4    | 7    |
|  8 | 4    | 4    | 8    |
+----+------+------+------+
4 rows in set (0.01 sec)

或者用下面的方法，不推荐
root@192.168.0.254 3306 [employees]>select * from (select distinct s.* from s1 s order by c3) a limit 0,4;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 | 1    | 1    | 1    |
|  2 | 2    | 2    | 2    |
|  3 | 3    | 3    | 3    |
|  4 | 4    | 4    | 4    |
+----+------+------+------+
4 rows in set (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from (select distinct s.* from s1 s order by c3) a limit 4,4;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  5 | 4    | 4    | 5    |
|  6 | 4    | 4    | 6    |
|  7 | 4    | 4    | 7    |
|  8 | 4    | 4    | 8    |
+----+------+------+------+
4 rows in set (0.01 sec)
```
count
```
1、基本用法求数量，注意count(fl_name)不计算空值，如果fl_name有值为null的话，可能数据不准确
root@192.168.0.254 3307 [employees]>select count(*) from t_order; //count(*)有二级索引就会走最小的二级索引，没有会走pk
+----------+
| count(*) |
+----------+
|       10 |
+----------+
1 row in set (0.00 sec)

root@192.168.0.254 3307 [employees]>desc select count(*) from t_order;
+----+-------------+---------+------------+-------+---------------+-------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+-------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_order | NULL       | index | NULL          | ix_t1 | 5       | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+-------+---------+------+------+----------+-------------+

2、不计算NULL
root@192.168.0.254 3307 [employees]>select count(emp_no) from t_order;    //emp_no中有一行为null
+---------------+
| count(emp_no) |
+---------------+
|             9 |
+---------------+
1 row in set (0.00 sec)

#如果字段有null值,且该列没有索引时只能全表查询
root@192.168.0.254 3307 [employees]>desc select count(emp_no) from t_order;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

总结：不影响业务情况下用count(*)， 只需记住count不计算null
```
MIN/MAX
```
1、求出最小值，最大数，数字列正常比较，但包括null，但不计算null,group by 可以对包含空null的分组
root@192.168.0.254 3307 [employees]>select * from t_order;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|   NULL | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>select min(emp_no),max(emp_no) from t_order;
+-------------+-------------+
| min(emp_no) | max(emp_no) |
+-------------+-------------+
|       10004 |       50449 |
+-------------+-------------+

min可以通过下面方法得出null
root@192.168.0.254 3307 [employees]>select case when min(ifnull(emp_no,'')) ='' then null end a from t_order;
+------+
| a    |
+------+
| NULL |
+------+
1 row in set (0.00 sec)

2、字符列正常比较，但包括null字符比较大小,但不是计算
root@192.168.0.254 3307 [employees]>select dept_no from t_order union all select null;
+---------+
| dept_no |
+---------+
| d006    |
| d005    |
| d005    |
| d002    |
| d005    |
| d008    |
| d008    |
| d007    |
| d005    |
| d004    |
| NULL    |
+---------+
11 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>select min(dept_no),max(dept_no) from (select dept_no from t_order union all select null) a;
+--------------+--------------+
| min(dept_no) | max(dept_no) |
+--------------+--------------+
| d002         | d008         |
+--------------+--------------+

ascii码来比较大小
root@192.168.0.254 3307 [employees]>select hex(dept_no) from t_order union all select hex(null);
+--------------+
| hex(dept_no) |
+--------------+
| 64303036     |
| 64303035     |
| 64303035     |
| 64303032     |
| 64303035     |
| 64303038     |
| 64303038     |
| 64303037     |
| 64303035     |
| 64303034     |
| NULL         |
+--------------+
11 rows in set (0.01 sec)

root@192.168.0.254 3307 [employees]>select min(dept_no),max(dept_no) from (select hex(dept_no) dept_no from t_order union all select hex(null)) a;
+--------------+--------------+
| min(dept_no) | max(dept_no) |
+--------------+--------------+
| 64303032     | 64303038     |
+--------------+--------------+
1 row in set (0.00 sec)


解决某个值是否存在表中，存在返回1，否则返回0的问题
root@192.168.0.254 3308 [employees]>select case when emp_no=10001001 then 1 else 0 end dd from salaries t where emp_no=10001001 limit 1;  //表中不存在emp_no=10001001，返回为空
Empty set (0.00 sec)

root@192.168.0.254 3308 [employees]>select case when emp_no=10001 then 1 else 0 end dd from salaries t where emp_no=10001 limit 1;   //表中存在emp_no=10001，返回为1
+----+
| dd |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

正确解决方案，用聚合函数，因为聚合函数至少返回1行数据
root@192.168.0.254 3307 [employees]>select case when max(emp_no) is null then 0 else 1 end as dd from salaries where emp_no=10001 limit 1;   //max
+----+
| dd |
+----+
|  1 |
+----+
1 row in set (0.04 sec)

root@192.168.0.254 3307 [employees]>select case when max(emp_no) is null then 0 else 1 end as dd from salaries where emp_no=10001001 limit 1;   //max
+----+
| dd |
+----+
|  0 |
+----+
1 row in set (0.02 sec)

root@192.168.0.254 3307 [employees]>select case when min(emp_no) is null then 0 else 1 end as dd from salaries where emp_no=10001 limit 1;    //min
+----+
| dd |
+----+
|  1 |
+----+
1 row in set (0.01 sec)

root@192.168.0.254 3307 [employees]>select case when min(emp_no) is null then 0 else 1 end as dd from salaries where emp_no=10001001 limit 1;     //min
+----+
| dd |
+----+
|  0 |
+----+
1 row in set (0.00 sec)



root@192.168.0.254 3307 [employees]>select max(first_name) first_name ,max(s1) from (
    -> select emp_no,first_name,now() s1 from emp3 where first_name='Sumali'
    -> union all
    -> select max(emp_no),max(first_name) first_name, ifnull(max(now()),now()) s1 from emp3 where first_name='Sumali2' 
    -> ) a group by emp_no;
+------------+---------------------+
| first_name | max(s1)             |
+------------+---------------------+
| NULL       | 2020-03-26 22:28:14 |
| Sumali     | 2020-03-26 22:28:14 |
| Sumali     | 2020-03-26 22:28:14 |
| Sumali     | 2020-03-26 22:28:14 |
| Sumali     | 2020-03-26 22:28:14 |
| Sumali     | 2020-03-26 22:28:14 |
+------------+---------------------+
6 rows in set (0.03 sec)

root@192.168.0.254 3307 [employees]>select max(first_name) first_name ,max(s1) from ( select emp_no,first_name,now() s1 from emp3 where first_name='Sumali2' union all select max(emp_no),max(first_name) first_name, ifnull(max(now()),now()) s1 from emp3 where first_name='Sumali2'  ) a group by emp_no;
+------------+---------------------+
| first_name | max(s1)             |
+------------+---------------------+
| NULL       | 2020-03-26 22:28:25 |
+------------+---------------------+
1 row in set (0.00 sec)


```
注意：
```
在group by + join 的在执行计划第一行中,同时出现了 using where,using temporary,using filesort,时，都是join后，对结果集再聚合，解决方法，将group by 提前即先聚合，再join,就会大大减少join的行数
```