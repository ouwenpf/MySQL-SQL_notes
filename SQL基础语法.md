SQL优化笔记，只记录了容易犯错的内容  
查询条件不满足相同类型的情况，可能会丢失数据  
```
root@192.168.0.254 3306 [employees]>desc test1;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | varchar(10) | YES  | MUL | NULL    |       |
| n     | varchar(10) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from test1;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
| NULL | NULL |
| 1aaa | NULL |
+------+------+
3 rows in set (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from test1 where id=100;
Empty set, 1 warning (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from test1 where id=1000;
+------+------+
| id   | n    |
+------+------+
| 1000 | NULL |
+------+------+
1 row in set, 1 warning (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from test1 where id=1; //原因是id列为varchar,字符串比较是按ACSII来比较,防止类型发生，字符串类型应加上''
+------+------+
| id   | n    |
+------+------+
| 1aaa | NULL |
+------+------+
1 row in set, 1 warning (0.00 sec)

root@192.168.0.254 3306 [employees]>select * from test1 where id='1';
Empty set (0.01 sec)
```
有条件的查询，IN必须写相同的类型的数据，且有去掉重复值的作用
```
root@192.168.0.254 3307 [employees]>desc t_group;
+-----------+---------+------+-----+---------+-------+
| Field     | Type    | Null | Key | Default | Extra |
+-----------+---------+------+-----+---------+-------+
| emp_no    | int(11) | NO   |     | NULL    |       |
| dept_no   | char(4) | NO   |     | NULL    |       |
| from_date | date    | NO   |     | NULL    |       |
| to_date   | date    | NO   |     | NULL    |       |
+-----------+---------+------+-----+---------+-------+
4 rows in set (3.45 sec)

root@192.168.0.254 3307 [employees]>select * from t_group;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.08 sec)

root@192.168.0.254 3307 [employees]>select * from t_group where emp_no in (22744,24007);
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
2 rows in set (0.02 sec)

root@192.168.0.254 3307 [employees]>select * from t_group where emp_no in (22744,24007,24007);    //去重的效果
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+

#mysql5.6 in里面类型不一样，则不能使用索引，走全表扫描，5.7以上没有此问题
root@192.168.0.254 3306 [employees]>show index from t_group;
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table   | Non_unique | Key_name   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| t_group |          1 | idx_emp_no |            1 | emp_no      | A         |          10 |     NULL | NULL   |      | BTREE      |         |               |
+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.05 sec)

root@192.168.0.254 3306 [employees]>explain extended select * from t_group where emp_no in (22744,'24007');
+----+-------------+---------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_group | ALL  | idx_emp_no    | NULL | NULL    | NULL |   10 |   100.00 | Using where |
+----+-------------+---------+------+---------------+------+---------+------+------+----------+-------------+

#5.7可以使用索引
root@192.168.0.254 3307 [employees]>explain extended select * from t_group where emp_no in (22744,'24007');
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t_group | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL |    2 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+

```

and  如果有大于等2个以上的条件需要用and 但是是不同的列
```
root@192.168.0.254 3307 [employees]>select * from t_group where emp_no=22744;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+

root@192.168.0.254 3307 [employees]>select * from t_group where emp_no=22744 and emp_no=24007;   //两个相同的列，不同的值，结果为空
Empty set (0.00 sec)
```
or对于一个列使用的时候等同于in ,对于不同的列进行使用的时候，特别注意时刻注意加括号，写SQL能不用or，尽量不用or
```
root@192.168.0.254 3307 [employees]>select * from t_group where emp_no in (48317,50449);
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
2 rows in set (0.00 sec)

root@192.168.0.254 3307 [employees]>select * from t_group where (emp_no=48317 or emp_no=50449);    //等同于in
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+

#or 条件放在不同的位置结果集是不一样的，所以写or一定要加()
root@192.168.0.254 3308 [employees]>select count(*) from employees where hire_date='1986-06-26' or last_name='simel' and emp_no=1002 and first_name ='Georgi';
+----------+
| count(*) |
+----------+
|       83 |
+----------+
1 row in set (0.45 sec)

root@192.168.0.254 3308 [employees]>select count(*) from employees where hire_date='1986-06-26'  and emp_no=1002 and first_name ='Georgi' or last_name='simel';
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.37 sec)


```
access 和filter条件
```
root@192.168.0.254 3307 [employees]>desc  select * from employees  where first_name='Bezalel';
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | idx_firstname | idx_firstname | 44      | const |  228 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

root@192.168.0.254 3307 [employees]>desc  select * from employees  where first_name='Bezalel' and  last_name like 'B%';
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ref  | idx_firstname | idx_firstname | 44      | const |  228 |    11.11 | Using where |
+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+

addess条件为 first_name ,即用到索引的条件
filter条件为 last_name  用了索引后再过滤的条件
```
延迟join
```
延迟join一般有limit 
例子如下
#下这行使用延时join没有回表，是在全部运行完成后在回表，主要是减少物理IO
root@192.168.0.254 3308 [employees]>desc select e.* from  (select emp_no from emp1 where first_name='Shem' order by emp_no limit 100000,10) c join emp1 e on c.emp_no = e.emp_no;
+----+-------------+------------+------------+--------+-------------------+--------------+---------+----------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys     | key          | key_len | ref      | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+-------------------+--------------+---------+----------+------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL              | NULL         | NULL    | NULL     |  235 |   100.00 | NULL        |
|  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY,ix_3      | PRIMARY      | 4       | c.emp_no |    1 |   100.00 | NULL        |
|  2 | DERIVED     | emp1       | NULL       | ref    | ix_firstname,ix_3 | ix_firstname | 44      | const    |  235 |   100.00 | Using index |
+----+-------------+------------+------------+--------+-------------------+--------------+---------+----------+------+----------+-------------+
3 rows in set, 1 warning (0.23 sec)

#下面这执行计划全部回表 
root@192.168.0.254 3308 [employees]>desc select * from emp1 where first_name='Parto' order by emp_no limit 10000,10;
+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | emp1  | NULL       | ref  | ix_firstname  | ix_firstname | 44      | const |  228 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
```
where 1=1作用,这样的代码是为了达到前后一致性,更好的格式化,1=1表示真(True)
```
root@192.168.0.254 3308 [employees]>select * from t_group where 1=1 and dept_no='d008';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
2 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>select * from t_group where 1=1 and emp_no=46554 and  dept_no='d008';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
+--------+---------+------------+------------+

root@192.168.0.254 3308 [employees]>select 1 where 1=0;
Empty set (0.00 sec)

root@192.168.0.254 3308 [employees]>select 1 where 1=1;
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set (0.00 sec)

root@192.168.0.254 3308 [employees]>select * from t_group where 0=0=case when emp_no=22744 then 1 end;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
```
group by 分组，简单概括就是分组之后的数据每个组只能出一行,使用group by 尽量使用局部查询
```
root@192.168.0.254 3308 [employees]>select dept_no,count(*) from t_group group by dept_no;
+---------+----------+
| dept_no | count(*) |
+---------+----------+
| d006    |        1 |
| d005    |        4 |
| d002    |        1 |
| d008    |        2 |
| d007    |        1 |
| d004    |        1 |
+---------+----------+
6 rows in set (0.00 sec)

当where条件是一个常数，group by 等同于下面SQL，原因是因为就只有一组数据,偶尔可以用于标量子查询
root@192.168.0.254 3308 [employees]>select min(dept_no),count(*) from t_group where dept_no='d005';
+--------------+----------+
| min(dept_no) | count(*) |
+--------------+----------+
| d005         |        4 |
+--------------+----------+

root@192.168.0.254 3308 [employees]>select max(dept_no),count(*) from t_group where dept_no='d005';
+--------------+----------+
| max(dept_no) | count(*) |
+--------------+----------+
| d005         |        4 |
+--------------+----------+
```
group by分组后可以结合聚合函数使用(count,min,max,sum)
```
root@192.168.0.254 3308 [employees]>select dept_no,count(*),min(emp_no),max(emp_no),sum(emp_no) from t_group where dept_no='d005' group by dept_no;
+---------+----------+-------------+-------------+-------------+
| dept_no | count(*) | min(emp_no) | max(emp_no) | sum(emp_no) |
+---------+----------+-------------+-------------+-------------+
| d005    |        4 |       24007 |       50449 |      146409 |
+---------+----------+-------------+-------------+-------------+

root@192.168.0.254 3308 [employees]>select dept_no,count(*),min(emp_no),max(emp_no),sum(emp_no) from t_group  group by dept_no;
+---------+----------+-------------+-------------+-------------+
| dept_no | count(*) | min(emp_no) | max(emp_no) | sum(emp_no) |
+---------+----------+-------------+-------------+-------------+
| d006    |        1 |       22744 |       22744 |       22744 |
| d005    |        4 |       24007 |       50449 |      146409 |
| d002    |        1 |       31112 |       31112 |       31112 |
| d008    |        2 |       46554 |       48317 |       94871 |
| d007    |        1 |       49667 |       49667 |       49667 |
| d004    |        1 |       10004 |       10004 |       10004 |
+---------+----------+-------------+-------------+-------------+
6 rows in set (0.01 sec)

root@192.168.0.254 3306 [employees]>desc select dept_no ,count(1) from dept_emp  group by dept_no;
+----+-------------+----------+-------+------------------------+---------+---------+------+--------+-------------+
| id | select_type | table    | type  | possible_keys          | key     | key_len | ref  | rows   | Extra       |
+----+-------------+----------+-------+------------------------+---------+---------+------+--------+-------------+
|  1 | SIMPLE      | dept_emp | index | PRIMARY,emp_no,dept_no | dept_no | 12      | NULL | 326341 | Using index |
+----+-------------+----------+-------+------------------------+---------+---------+------+--------+-------------+

root@192.168.0.254 3306 [employees]>desc  select dept_no ,count(1) from dept_emp where dept_no='d001' group by dept_no;    //使用局部查询
+----+-------------+----------+------+------------------------+---------+---------+-------+-------+--------------------------+
| id | select_type | table    | type | possible_keys          | key     | key_len | ref   | rows  | Extra                    |
+----+-------------+----------+------+------------------------+---------+---------+-------+-------+--------------------------+
|  1 | SIMPLE      | dept_emp | ref  | PRIMARY,emp_no,dept_no | dept_no | 12      | const | 40528 | Using where; Using index |
+----+-------------+----------+------+------------------------+---------+---------+-------+-------+--------------------------+

经典案例
root@192.168.0.254 3308 [employees]>desc select * from t_group t left join (select dept_no ,count(1) from dept_emp d group by dept_no) e on t.dept_no = e.dept_no;
+----+-------------+------------+------------+-------+------------------------+-------------+---------+---------------------+--------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys          | key         | key_len | ref                 | rows   | filtered | Extra       |
+----+-------------+------------+------------+-------+------------------------+-------------+---------+---------------------+--------+----------+-------------+
|  1 | PRIMARY     | t          | NULL       | ALL   | NULL                   | NULL        | NULL    | NULL                |     10 |   100.00 | NULL        |
|  1 | PRIMARY     | <derived2> | NULL       | ref   | <auto_key0>            | <auto_key0> | 12      | employees.t.dept_no |   3311 |   100.00 | NULL        |
|  2 | DERIVED     | d          | NULL       | index | PRIMARY,emp_no,dept_no | dept_no     | 12      | NULL                | 331143 |   100.00 | Using index |
+----+-------------+------------+------------+-------+------------------------+-------------+---------+---------------------+--------+----------+-------------+


root@192.168.0.254 3308 [employees]>desc   select * from t_group t left join (select dept_no ,count(1) c from dept_emp d where exists (select dept_no from t_group g where d.dept_no=g.dept_no) group by dept_no) e on t.dept_no = e.dept_no;
+----+--------------+-------------+------------+------+------------------------+-------------+---------+---------------------+-------+----------+-----------------+
| id | select_type  | table       | partitions | type | possible_keys          | key         | key_len | ref                 | rows  | filtered | Extra           |
+----+--------------+-------------+------------+------+------------------------+-------------+---------+---------------------+-------+----------+-----------------+
|  1 | PRIMARY      | t           | NULL       | ALL  | NULL                   | NULL        | NULL    | NULL                |    10 |   100.00 | NULL            |
|  1 | PRIMARY      | <derived2>  | NULL       | ref  | <auto_key0>            | <auto_key0> | 12      | employees.t.dept_no |   413 |   100.00 | NULL            |
|  2 | DERIVED      | <subquery3> | NULL       | ALL  | NULL                   | NULL        | NULL    | NULL                |  NULL |   100.00 | Using temporary |
|  2 | DERIVED      | d           | NULL       | ref  | PRIMARY,emp_no,dept_no | dept_no     | 12      | <subquery3>.dept_no | 41392 |   100.00 | Using index     |
|  3 | MATERIALIZED | g           | NULL       | ALL  | NULL                   | NULL        | NULL    | NULL                |    10 |   100.00 | NULL            |
+----+--------------+-------------+------------+------+------------------------+-------------+---------+---------------------+-------+----------+-----------------+
5 rows in set, 2 warnings (0.00 sec)


root@192.168.0.254 3308 [employees]>desc select t.*,(select count(1) c from dept_emp d where t.dept_no=d.dept_no ) from t_group t;
+----+--------------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+-------------+
| id | select_type        | table | partitions | type | possible_keys | key     | key_len | ref                 | rows  | filtered | Extra       |
+----+--------------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+-------------+
|  1 | PRIMARY            | t     | NULL       | ALL  | NULL          | NULL    | NULL    | NULL                |    10 |   100.00 | NULL        |
|  2 | DEPENDENT SUBQUERY | d     | NULL       | ref  | dept_no       | dept_no | 12      | employees.t.dept_no | 41392 |   100.00 | Using index |
+----+--------------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+-------------+

上面三条SQL等价，结果集一样，
```
group by分组mysql5.6的时候经常出现下面SQL，就是不完全分组,这是一种错误,随着执行计划的变化，可能结果集会不一样
```
root@192.168.0.254 3308 [employees]>select * from t_group where dept_no='d005';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
4 rows in set (0.30 sec)

root@192.168.0.254 3308 [employees]>select * from t_group where dept_no='d005' group by dept_no;
ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'employees.t_group.emp_no' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
root@192.168.0.254 3308 [employees]>set sql_mode='';
Query OK, 0 rows affected (0.47 sec)

root@192.168.0.254 3308 [employees]>select * from t_group where dept_no='d005' group by dept_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
1 row in set (0.00 sec)

结果不一样例子如下，在MySQL8.0下测试
root@192.168.0.254 3308 [employees]>select * from t_group where dept_no='d005' group by dept_no;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
1 row in set (0.00 sec)

root@192.168.0.254 3308 [employees]>show index from t_group;
Empty set (0.13 sec)

root@192.168.0.254 3308 [employees]>create index idx_2 on t_group(dept_no asc,emp_no desc);
Query OK, 0 rows affected (4.95 sec)
Records: 0  Duplicates: 0  Warnings: 0

root@192.168.0.254 3308 [employees]>select * from t_group where dept_no='d005' group by dept_no;     //结果跟上面语句不一样了
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
1 row in set (0.02 sec)

```
order by 排序，可升序，降序
```
使用order by 排序时，如果排序字段有多个重复值时可能结果会超出预料之中，如下面三个SQL
root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc limit 10;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

to_date中有6个9999-01-01，从mysql上来看随便哪个在前后都是正确，但是从业务上来看不是这么认为

root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc limit 0,5;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
5 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc limit 5,5;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
5 rows in set (0.00 sec)

10004出现在上面两条SQL结果集中
解决这种问题的方法是，创建索引或者再增加另一字段排序，如下面SQL，
root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc ,emp_no limit 10;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc ,emp_no limit 0,5;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
5 rows in set (0.00 sec)

root@192.168.0.254 3308 [employees]>select * from t_group order by to_date desc ,emp_no limit 5,5;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
5 rows in set (0.00 sec)

关于order by 排序,主要是看where后面的过滤条件
#这条语句，结果集只有一行，Extra则是using filesort ,可以忽略
root@192.168.0.254 3308 [employees]>desc select * from dept_emp where emp_no=10004 order by to_date desc limit 10;
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+----------------+
| id | select_type | table    | partitions | type | possible_keys  | key     | key_len | ref   | rows | filtered | Extra          |
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+----------------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY,emp_no | PRIMARY | 4       | const |    1 |   100.00 | Using filesort |
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)

#下面这条语句，结果集太大，Extra则是using filesort，必然耗时更长,
root@192.168.0.254 3308 [employees]>desc select * from dept_emp where emp_no>0 order by to_date desc limit 10;
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-----------------------------+
| id | select_type | table    | partitions | type  | possible_keys  | key     | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | dept_emp | NULL       | range | PRIMARY,emp_no | PRIMARY | 4       | NULL | 165571 |   100.00 | Using where; Using filesort |
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-----------------------------+
1 row in set, 1 warning (0.09 sec)

#由于是按to_date进行order by 排序的，那么我的建立索引包含字段to_date
root@192.168.0.254 3308 [employees]>alter table dept_emp add index idx_1 (to_date);
Query OK, 0 rows affected (7.36 sec)
Records: 0  Duplicates: 0  Warnings: 0

#现在执行计划相对上条SQL会高效一些
root@192.168.0.254 3308 [employees]>desc select * from dept_emp where emp_no>0 order by to_date desc limit 10;
+----+-------------+----------+------------+-------+----------------+-------+---------+------+------+----------+----------------------------------+
| id | select_type | table    | partitions | type  | possible_keys  | key   | key_len | ref  | rows | filtered | Extra                            |
+----+-------------+----------+------------+-------+----------------+-------+---------+------+------+----------+----------------------------------+
|  1 | SIMPLE      | dept_emp | NULL       | index | PRIMARY,emp_no | idx_1 | 3       | NULL |   20 |    50.00 | Using where; Backward index scan |
+----+-------------+----------+------------+-------+----------------+-------+---------+------+------+----------+----------------------------------+
1 row in set, 1 warning (0.02 sec)

```
LIMIT 最终返回数，主要用于分页
```
见上面几个SQL
数据量大，建议使用延时join
```
having一般应用于group by 之后，对结果进行二次排序,也相当于一个子查询
```
root@192.168.0.254 3308 [employees]>select dept_no,count(*) from t_group group by dept_no having count(*) >=4;
+---------+----------+
| dept_no | count(*) |
+---------+----------+
| d005    |        4 |
+---------+----------+
1 row in set (0.00 sec)

#将having改为子查询
root@192.168.0.254 3308 [employees]>select * from (select dept_no,count(*) as num  from t_group group by dept_no) s where s.num >=4;
+---------+-----+
| dept_no | num |
+---------+-----+
| d005    |   4 |
+---------+-----+
1 row in set (0.01 sec)

```
子查询,这里的子查询是指from后面使用括号，括起来的select部分，需要注意，必须要别名
```
例：
root@192.168.0.254 3308 [employees]>select s.* from (select * from t_group) s where s.emp_no='30970';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
+--------+---------+------------+------------+
1 row in set (0.01 sec)

#标量子查询，介于select 和 from 中的子查询，特点是：只能返回一行数据，或者null,相当于一个函数,尽量避免使用自定义函数，尽量用原生函数,标量子查询一定要写在最外层，有多少线结果集就会运行多少次，以及标量子查询中条件一定要有索引
MySQL5.6,每加一个（），则会生成一个tmp表,有可能会有性能问题
MySQL5.7以上有视图合并功能，性能会高一些，但是有视图合并，也有好之处，和不好之处，具体问题具体分析看执行计划
root@192.168.0.254 3308 [employees]>select t.*,(select e.emp_no from employees e where e.emp_no=t.emp_no) s from t_group t;    //标量子查询,有多少行数据，这个标量子查询就会运行多少次
+--------+---------+------------+------------+-------+
| emp_no | dept_no | from_date  | to_date    | s     |
+--------+---------+------------+------------+-------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 | 22744 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 | 24007 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 | 30970 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 | 31112 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 | 40983 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 | 46554 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 | 48317 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 | 49667 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 | 50449 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 | 10004 |
+--------+---------+------------+------------+-------+

```
